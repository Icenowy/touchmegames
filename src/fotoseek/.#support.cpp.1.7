
/*	Copyright (C) 2005, 2006 by Andy Grebe a.k.a. tecknophreak(tecknophreak@gmail.com)
 *
 *	This file is part of TouchMe Games.
 *
 *	TouchMe Games is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	TouchMe Games is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with TouchMe Games; if not, write to the Free Software
 *	Foundation, Inc., 59 Temple Place, Suite 328, Boston, MA  02111-1287  USA
 */

// support functions for FotoSeek
// Functions which basically don't fit in
// events.cpp or interface.cpp

#include <fotoseek.h>
#include <sstream>

FotoSeek::FotoSeek() : gameName("fotoseek") {
    imageWidth = 300;
    imageHeight = 400;
    gameHeight = 600;
    gameWidth = 800;
    
    playXOffset = 95;
    playYOffset = 150;
    
    foundColor = 0x00FFFF00;
    missedColor = 0x00FFFF00;
    matchColor = 0x00FF0000;
}

std::string FotoSeek::name() const {
    return gameName;
}

std::string FotoSeek::imageName() const {
    return "fotoseek.gif";
}

// This function doesn't even do anything anymore...really
// The background should be a modified bg.png
GdkColor *FotoSeek::backgroundColor() {
    return &bgcolor;
}

void FotoSeek::startRound() {
//     std::stringstream sstr;
//     
//     if (round + 1 == 4) {
//         gameState = GAME_OVER;
//         return;
//     }
//     
//     if (++round < 3) {
//         maxColumns = 6;
//         maxRows = 6;
//         perXSector = 3;
//         perYSector = 2;
//         maxInt = 6;
//     }
//     
//     if (round == 1) {
//         generatePuzzle(10, 20, 20);
//         
//     }
//     else if (round == 2) {
//         generatePuzzle(10, 20, 24);
//     }
//     else {
//         return;
//     }
//     sstr << round;
//     gtk_label_set_text((GtkLabel *)roundLabel, sstr.str().c_str());
//     
//     gameState = RUNNING;
//     timeLeft = 600;
//     
//     roundScore = 0;
//     errors = 0;
//     currentInt = 0;
    
    leftImage.reloadImage("fotoseek/images/2a.png");
    leftImage.scale(imageWidth, imageHeight);
    
    rightImage.reloadImage("fotoseek/images/2b.png");
    rightImage.scale(imageWidth, imageHeight);
    rightImage.repaint();
    
    imageMask.reloadImage("fotoseek/images/2mask.png");
    imageMask.scale(imageWidth, imageHeight);
    imageMask.repaint();
}


GtkWidget *FotoSeek::getHelp() {
    GtkWidget *vbox;
    GtkWidget *label;
    GdkColor color;
    std::stringstream sstr;
    
    // Keep this color
    color.red = 0xFFFF;
    color.green = 0xFFFF;
    color.blue = 0xFFFF;
    
    vbox = gtk_vbox_new(FALSE, 0);
    
    sstr << "fotoseek is a fotoseek which you\n"
            << "have to fill out the rest of the code.";
        
    label = gtk_label_new(sstr.str().c_str());
    gtk_widget_modify_fg(label, (GtkStateType)0, &color);
    gtk_box_pack_start((GtkBox *)vbox, label, FALSE, FALSE, 10);
    return vbox;
}

int FotoSeek::gameType() const {
    return UNKNOWN_GAME;
}



char FotoSeek::roundOver() {
    if (round == 2) {
        FotoSeek *s(this);
        exitGame(NULL, (void **)&s);
        return 0;
    }
    return 0;
}


void FotoSeek::checkCircle(int x, int y) {
    
    std::cout << std::hex << imageMask.getColor(x, y) << std::dec << std::endl;
    
    if (imageMask.getColor(x, y) == matchColor) {
        std::cout << "Found difference" << std::endl;
        paintOutside(x, y, true);
    }
    return;
    
    
//     GdkPixbuf *pixbuf = NULL;
//     int width, height, rowstride, numChannels;
//     guchar *pixels, *p;
//     
//     std::cout << "X: " << x << " Y: " << y << std::endl;
//     
//     if (gtk_image_get_storage_type((GtkImage *)imageMask) == GTK_IMAGE_PIXBUF) {
//         
//         pixbuf = gtk_image_get_pixbuf((GtkImage *)imageMask);
//         if (pixbuf == NULL) {
//             std::cout << "Could not get pixbuf from image!!" << std::endl;
//         }
//         else {
//             unsigned long color;
//             unsigned long inside(0xFF0000), outside(0xFFFF00);
//             
//             numChannels = gdk_pixbuf_get_n_channels(pixbuf);
// //             std::cout << "Number of Channels: " << numChannels << std::endl;
//             
//             
//             g_assert(gdk_pixbuf_get_colorspace(pixbuf) == GDK_COLORSPACE_RGB);
//             g_assert(gdk_pixbuf_get_bits_per_sample(pixbuf) == 8);
// //             g_assert(gdk_pixbuf_get_has_alpha(pixbuf));
// //             g_assert(numChannels == 4);
//             
//             width = gdk_pixbuf_get_width (pixbuf);
//             height = gdk_pixbuf_get_height (pixbuf);
// 
//             g_assert(x >= 0 && x < width);
//             g_assert(y >= 0 && y < height);
//             
//             rowstride = gdk_pixbuf_get_rowstride (pixbuf);
//             pixels = gdk_pixbuf_get_pixels (pixbuf);
// 
//             p = pixels + y * rowstride + x * numChannels;
//             
// //             std::cout << std::hex << (int)p[0] << ' ' << (int)p[1] << ' ' << (int)p[2] << std::endl;
//             
//             // I know this line could probably be easier
//             color = (((unsigned long)p[0]) << 16) | (((unsigned long)p[1]) << 8) | (unsigned long)p[2];
//             
//             if (color == inside) {
//                 std::cout << "You have a match!!" << std::endl;
//                 paintOutside(x, y, true);
//                 pixbuf = gtk_image_get_pixbuf((GtkImage *)leftImage);
//                 pixbuf = gdk_pixbuf_scale_simple(pixbuf, (int)((float)imageWidth * 0.75), (int)((float)imageHeight * 0.75),
//                         GDK_INTERP_BILINEAR);
//                 gtk_image_set_from_pixbuf((GtkImage *)leftImage, pixbuf);
//             }
//             
//         }
//     }
//     else {
//         std::cout << "This is not a pixbuf image" << std::endl;
//     }
//     
}
